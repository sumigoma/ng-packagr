{"version":3,"file":"sorcery.js","sourceRoot":"","sources":["../../../src/lib/steps/sorcery.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,mCAAmC;AAInC,uCAA+C;AAC/C,qCAAoC;AAEpC;;;;;GAKG;AACH,wBAAqC,UAAkB;;QACrD,WAAK,CAAC,0BAA0B,UAAU,EAAE,CAAC,CAAC;QAC9C,MAAM,IAAI,GAAQ;YAChB,MAAM,EAAE,KAAK;YACb,cAAc,EAAE,IAAI;SACrB,CAAC;QAEF,gGAAgG;QAChG,MAAM,KAAK,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC7C,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,IAAI,KAAK,CAAC,qCAAqC,GAAG,UAAU,CAAC,CAAC;QACtE,CAAC;QAED,MAAM,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;CAAA;AAdD,wCAcC;AAGD;;;;;;;;;GASG;AACH,kCACE,EAAE,SAAS,EAAE,UAAU,EAAwD;;QAE/E,MAAM,sBAAe,CAAC,GAAG,SAAS,CAAC,QAAQ,sCAAsC,EAC/E,CAAC,SAAc,EAAO,EAAE;YACtB,SAAS,CAAC,OAAO,GAAI,SAAS,CAAC,OAAoB;iBAChD,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;gBACZ,IAAI,WAAW,GAAG,IAAI,CAAC;gBACvB,qCAAqC;gBACrC,OAAO,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;oBACrC,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACzC,CAAC;gBAED,MAAM,CAAC,QAAQ,UAAU,CAAC,QAAQ,IAAI,WAAW,EAAE,CAAC;YACtD,CAAC,CAAC,CAAC;YAEL,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC,CACF,CAAC;IACJ,CAAC;CAAA;AAnBD,4DAmBC","sourcesContent":["import * as sorcery from 'sorcery';\nimport { NgArtefacts } from '../ng-package-format/artefacts';\nimport { NgEntryPoint } from '../ng-package-format/entry-point';\nimport { NgPackage } from '../ng-package-format/package';\nimport { modifyJsonFiles } from '../util/json';\nimport { debug } from '../util/log';\n\n/**\n * Re-maps the source `.map` file for the given `sourceFile`. This keeps source maps intact over\n * a series of transpilations!\n *\n * @param sourceFile Source file\n */\nexport async function remapSourceMap(sourceFile: string): Promise<void> {\n  debug(`re-mapping sources for ${sourceFile}`);\n  const opts: any = {\n    inline: false,\n    includeContent: true,\n  };\n\n  // Once sorcery loads the chain of sourcemaps, the new sourcemap will be written asynchronously.\n  const chain = await sorcery.load(sourceFile);\n  if (!chain) {\n    throw new Error('Failed to load sourceMap chain for ' + sourceFile);\n  }\n\n  await chain.write(opts);\n}\n\n\n/**\n * Relocates pathes of the `sources` file array in `*.js.map` files.\n *\n * Simply said, because `sourcesContent` are inlined in the source maps, it's possible to pass an\n * arbitrary file name and path in the `sources` property. By setting the value to a common prefix,\n * i.e. `ng://@org/package/secondary`,\n * the source map p `.map` file's relative root file paths to the module's name.\n *\n * @param pkg Angular package\n */\nexport async function relocateSourceMapSources(\n  { artefacts, entryPoint }: { artefacts: NgArtefacts, entryPoint: NgEntryPoint }): Promise<void> {\n\n  await modifyJsonFiles(`${artefacts.stageDir}/+(bundles|esm2015|esm5)/**/*.js.map`,\n    (sourceMap: any): any => {\n      sourceMap.sources = (sourceMap.sources as string[])\n        .map((path) => {\n          let trimmedPath = path;\n          // Trim leading '../' path separators\n          while (trimmedPath.startsWith('../')) {\n            trimmedPath = trimmedPath.substring(3);\n          }\n\n          return `ng://${entryPoint.moduleId}/${trimmedPath}`;\n        });\n\n      return sourceMap;\n    }\n  );\n}\n"]}